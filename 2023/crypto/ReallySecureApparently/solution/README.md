[COMMUNITY WRITEUP](https://meashiri.github.io/ctf-writeups/posts/202311-1337up/#really-secure-apparently)

#### solve.py

```py
import owiener
import binascii

e = 98161001623245946455371459972270637048947096740867123960987426843075734419854169415217693040603943985614577854750928453684840929755254248201161248375350238628917413291201125030514500977409961838501076015838508082749034318410808298025858181711613372870289482890074072555265382600388541381732534018133370862587
n = 689061037339483636851744871564868379980061151991904073814057216873412583484720768694905841053416938972235588548525570270575285633894975913717130070544407480547826227398039831409929129742007101671851757453656032161443946817685708282221883187089692065998793742064551244403369599965441075497085384181772038720949

# Load the ciphertext as an integer from a binary file (adjust the file path accordingly)
with open('ciphertext', 'rb') as f:
    ciphertext_int = int.from_bytes(f.read(), byteorder='big')

# Use the Wiener's Attack to recover the private exponent (d)
d = owiener.attack(e, n)

# Decrypt the ciphertext and convert it to plaintext
flag = pow(ciphertext_int, d, n).to_bytes((ciphertext_int.bit_length() + 7) // 8, byteorder='big')
print(f"Flag: {flag}")
```
